/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.android.as.oss.fl.federatedcompute.logging.statsd;

import static com.google.android.as.oss.logging.converter.PcsLogMessageConverter.HISTOGRAM_COUNTER_CONVERTER;
import static com.google.android.as.oss.logging.converter.PcsLogMessageConverter.LONG_HISTOGRAM_COUNTER_CONVERTER;
import static com.google.android.as.oss.logging.converter.PcsLogMessageConverter.TIMER_HISTOGRAM_COUNTER_CONVERTER;
import static com.google.android.as.oss.networkusage.db.NetworkUsageLogUtils.createFcTrainingResultNetworkUsageEntity;
import static com.google.common.logging.fc.logs.FcLog.TrainerLogEvent.TrainingEventKind.SECAGG_CLIENT_LOG_EVENT;
import static java.util.concurrent.TimeUnit.MINUTES;

import android.os.SystemClock;
import androidx.annotation.Nullable;
import com.google.android.as.oss.asi.common.logging.DurationBucketLogic;
import com.google.android.as.oss.asi.logging.Logcat;
import com.google.android.as.oss.fl.federatedcompute.config.PcsFcFlags;
import com.google.android.as.oss.fl.federatedcompute.logging.FcLogManager;
import com.google.android.as.oss.fl.federatedcompute.statsd.StatsdExampleStoreConnector;
import com.google.android.as.oss.logging.PcsAtomsProto.IntelligenceFederatedLearningDiagnosisLogReported;
import com.google.android.as.oss.logging.PcsAtomsProto.IntelligenceFederatedLearningSecAggClientLogReported;
import com.google.android.as.oss.logging.PcsAtomsProto.IntelligenceFederatedLearningTrainingLogReported;
import com.google.android.as.oss.logging.PcsStatsEnums;
import com.google.android.as.oss.logging.PcsStatsEnums.CollectionName;
import com.google.android.as.oss.logging.PcsStatsEnums.SecAggClientCryptoOperationType;
import com.google.android.as.oss.logging.PcsStatsEnums.SecAggClientErrorCode;
import com.google.android.as.oss.logging.PcsStatsEnums.SecAggClientEventKind;
import com.google.android.as.oss.logging.PcsStatsEnums.SecAggClientRound;
import com.google.android.as.oss.logging.PcsStatsEnums.TrainingDataSourceType;
import com.google.android.as.oss.logging.PcsStatsEnums.TrainingErrorCode;
import com.google.android.as.oss.logging.PcsStatsEnums.TrainingEventKind;
import com.google.android.as.oss.logging.PcsStatsLog;
import com.google.android.as.oss.networkusage.db.NetworkUsageEntity;
import com.google.android.as.oss.networkusage.db.NetworkUsageLogRepository;
import com.google.fcp.client.LogManager.LoggingTimer;
import com.google.fcp.client.LogManager.LongHistogramCounter;
import com.google.fcp.client.LogManager.TimerHistogramCounter;
import com.google.fcp.client.internal.ClientConstants;
import com.google.android.libraries.learning.proto.DebugDiagCode;
import com.google.android.libraries.learning.proto.ProdDiagCode;
import com.google.common.collect.ImmutableSet;
import com.google.common.flogger.GoogleLogger;
import com.google.common.flogger.android.AndroidFluentLogger;
import com.google.common.logging.fc.logs.FcLog.FcLogEvent;
import com.google.common.logging.fc.logs.FcLog.CountersDimensions;
import com.google.common.logging.fc.logs.FcLog.DiagnosisLogEvent;
import com.google.common.logging.fc.logs.FcLog.TrainerLogEvent;
import com.google.common.logging.fc.logs.FcLog.TrainerLogEvent.DataTransferInfo;
import com.google.common.logging.fc.logs.FcLog.TrainerLogEvent.MemoryUsageInfo;
import com.google.common.logging.fc.logs.SecAggLog.SecAggClientLogEvent;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.intelligence.fcp.client.HistogramCounters;
import com.google.protobuf.MessageLite;
import java.util.Random;
import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * Statsd implementation of {@link FcLogManager}. PCS owns the logs generated by FC from inside PCS
 * and we log them via Statsd.
 */
@Singleton
public class FcClientStatsdLogManager implements FcLogManager {
  private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();
  private static final AndroidFluentLogger nonRedactingLogger = Logcat.fc();
  private static final String PCS_PACKAGE_NAME = "com.google.android.as.oss";
  private static final int INFO_LOG_MSG_PERIOD_MINUTES = 60;

  private static final int FEDERATED_COMPUTE_VERSION = ClientConstants.MODULE_VERSION;

  private static final ImmutableSet<TrainerLogEvent.TrainingEventKind> TENSOR_FLOW_ERROR_EVENTS =
      ImmutableSet.of(
          TrainerLogEvent.TrainingEventKind.TRAIN_COMPUTATION_ERROR_TENSORFLOW,
          TrainerLogEvent.TrainingEventKind.TRAIN_ELIGIBILITY_EVAL_COMPUTATION_ERROR_TENSORFLOW);

  private final PcsFcFlags flags;
  private final PcsStatsLog statsdLogger;
  private final Random random;
  private final DurationBucketLogic durationBucketLogic;

  private final NetworkUsageLogRepository networkUsageLogRepository;

  @Inject
  FcClientStatsdLogManager(
      PcsFcFlags flags,
      PcsStatsLog statsdLogger,
      DurationBucketLogic durationBucketLogic,
      NetworkUsageLogRepository networkUsageLogRepository) {
    this.flags = flags;
    this.statsdLogger = statsdLogger;
    this.random = new Random();
    this.durationBucketLogic = durationBucketLogic;
    this.networkUsageLogRepository = networkUsageLogRepository;
  }

  @Override
  public void logEvent(@Nullable FcLogEvent event) {
    if (event == null || !isLoggingEnabled()) {
      return;
    }

    if (networkUsageLogRepository.getDbExecutor().isPresent() && hasNetworkDataTransfer(event)) {
      networkUsageLogRepository
          .getDbExecutor()
          .get()
          .execute(() -> insertNetworkUsageLogRow(event));
    }

    nonRedactingLogger.atDebug().log(event);
    if (event.hasDiagnosisLog()) {
      logDiag(event.getDiagnosisLog());
      return;
    }

    if (event.hasTrainerLog()) {
      logTrainerEvent(event.getTrainerLog());
      return;
    }

    // Only diag codes and trainer logs are supported right now.
    logger.atFine().log("Unsupported type of log from FL.");
  }

  private boolean hasNetworkDataTransfer(FcLogEvent event) {
    DataTransferInfo dataTransferInfo = event.getTrainerLog().getDataTransfer();
    return dataTransferInfo.getChunkingLayerBytesDownloaded() != 0
        || dataTransferInfo.getChunkingLayerBytesUploaded() != 0;
  }

  @Override
  public void logDiag(DebugDiagCode code) {
    nonRedactingLogger.atDebug().log("DebugDiagCode: %s", code);
    logDiag(code, null);
  }

  @Override
  public void logDiag(DebugDiagCode code, @Nullable String clientPackageName) {
    if (!flags.isProductionDiagnosisEnabled() || !flags.isDebugDiagnosisEnabled()) {
      return;
    }
    logDiag(code.getNumber(), 0);
  }

  @Override
  public void logDiag(ProdDiagCode code) {
    logDiag(code, null);
  }

  @Override
  public void logDiag(ProdDiagCode code, @Nullable String clientPackageName) {
    if (!flags.isProductionDiagnosisEnabled()) {
      return;
    }
    logDiag(code.getNumber(), 0);
  }

  private void logDiag(DiagnosisLogEvent diagnosisLog) {
    if (diagnosisLog.hasRunId()) {
      logDiag(diagnosisLog.getDiagCode(), diagnosisLog.getRunId());
    } else {
      logDiag(diagnosisLog.getDiagCode(), 0);
    }
  }

  private void logDiag(long diagCode, long runId) {
    if (!isLoggingEnabled()) {
      return;
    }
    IntelligenceFederatedLearningDiagnosisLogReported.Builder diagBuilder =
        IntelligenceFederatedLearningDiagnosisLogReported.newBuilder()
            .setFederatedComputeVersion(FEDERATED_COMPUTE_VERSION)
            .setDiagCode(diagCode);
    if (runId != 0) {
      diagBuilder.setRunId(runId);
    }
    logger.atInfo().atMostEvery(INFO_LOG_MSG_PERIOD_MINUTES, MINUTES).log(
        "Sending FL diagnosis log.");
    statsdLogger.logIntelligenceFlDiagLogReported(diagBuilder.build());
  }

  @CanIgnoreReturnValue
  @Override
  public FcLogEvent mergeWithDefaultDimensions(FcLogEvent additionalDimensions) {
    return additionalDimensions;
  }

  @Override
  public LoggingTimer measureTimeFromNow(
      TimerHistogramCounter counter, @Nullable FcLogEvent dimensions) {
    return measureTimeFromNow(TIMER_HISTOGRAM_COUNTER_CONVERTER.apply(counter), dimensions);
  }

  @Override
  public LoggingTimer measureTimeFromNow(
      HistogramCounters counter, @Nullable FcLogEvent dimensions) {
    return measureTimeFromNow(HISTOGRAM_COUNTER_CONVERTER.apply(counter), dimensions);
  }

  private LoggingTimer measureTimeFromNow(
      PcsStatsEnums.HistogramCounters counter, @Nullable FcLogEvent dimensions) {
    return measureTimeFromReference(counter, dimensions, SystemClock.elapsedRealtime());
  }

  @Override
  public LoggingTimer measureTimeFromReference(
      TimerHistogramCounter counter, @Nullable FcLogEvent dimensions, long referenceTimeMs) {
    return measureTimeFromReference(
        TIMER_HISTOGRAM_COUNTER_CONVERTER.apply(counter), dimensions, referenceTimeMs);
  }

  @Override
  public LoggingTimer measureTimeFromReference(
      HistogramCounters counter, @Nullable FcLogEvent dimensions, long referenceTimeMs) {
    return measureTimeFromReference(
        HISTOGRAM_COUNTER_CONVERTER.apply(counter), dimensions, referenceTimeMs);
  }

  private LoggingTimer measureTimeFromReference(
      PcsStatsEnums.HistogramCounters counter,
      @Nullable FcLogEvent dimensions,
      long referenceTimeMs) {
    return () ->
        incrementCounter(
            counter,
            dimensions,
            snapDurationToBucket(SystemClock.elapsedRealtime() - referenceTimeMs));
  }

  @Override
  public void incrementCounter(
      LongHistogramCounter counter, @Nullable FcLogEvent dimensions, long key) {
    incrementCounter(LONG_HISTOGRAM_COUNTER_CONVERTER.apply(counter), dimensions, key);
  }

  @Override
  public void incrementCounter(
      HistogramCounters counter, @Nullable FcLogEvent dimensions, long key) {
    incrementCounter(HISTOGRAM_COUNTER_CONVERTER.apply(counter), dimensions, key);
  }

  private void incrementCounter(
      PcsStatsEnums.HistogramCounters counter, @Nullable FcLogEvent dimensions, long key) {
    if (!isTrainingCounterLoggingEnabled()) {
      return;
    }

    IntelligenceFederatedLearningTrainingLogReported.Builder atomBuilder =
        IntelligenceFederatedLearningTrainingLogReported.newBuilder()
            .setFederatedComputeVersion(FEDERATED_COMPUTE_VERSION);
    if (dimensions != null) {
      if (dimensions.hasTrainerLog()) {
        TrainerLogEvent trainerLogEvent = dimensions.getTrainerLog();
        if (trainerLogEvent.hasConfigName()) {
          atomBuilder.setConfigName(trainerLogEvent.getConfigName());
        }
        if (trainerLogEvent.hasRunId()) {
          atomBuilder.setRunId(trainerLogEvent.getRunId());
        }
        if (trainerLogEvent.hasModelIdentifier()) {
          atomBuilder.setModelIdentifier(trainerLogEvent.getModelIdentifier());
        }
      }

      if (dimensions.hasAdditionalCountersDimensions()) {
        CountersDimensions additionalDimensions = dimensions.getAdditionalCountersDimensions();
        if (additionalDimensions.hasExampleStoreDimensions()) {
          atomBuilder.setCollectionName(
              getCollectionNameEnum(
                  additionalDimensions.getExampleStoreDimensions().getCollection()));
        }
      }
    }

    atomBuilder.setHistogramCounter(counter);
    atomBuilder.setCounterValue(key);

    IntelligenceFederatedLearningTrainingLogReported atom = atomBuilder.build();
    if (validateSerializedAtomSize(atom)) {
      logger.atInfo().atMostEvery(INFO_LOG_MSG_PERIOD_MINUTES, MINUTES).log(
          "Sending Training Counter log.");
      statsdLogger.logIntelligenceFlTrainingLogReported(atom);
    }
  }

  @Override
  public void flushLogs() {}

  private CollectionName getCollectionNameEnum(String collection) {
    return switch (collection) {
      case "/simple_storage_collection" -> CollectionName.COLLECTION_NAME_SIMPLESTORAGE;
      case StatsdExampleStoreConnector.STATSD_COLLECTION_NAME ->
          CollectionName.COLLECTION_NAME_STATSD;
      default -> CollectionName.COLLECTION_NAME_UNDEFINED;
    };
  }

  private void logTrainerEvent(TrainerLogEvent event) {
    if (event.hasSecaggClientLogEvent()) {
      logSecAggEvent(event);
      return;
    }

    IntelligenceFederatedLearningTrainingLogReported.Builder atomBuilder =
        IntelligenceFederatedLearningTrainingLogReported.newBuilder()
            .setFederatedComputeVersion(FEDERATED_COMPUTE_VERSION);

    if (event.hasKind()) {
      if (event.getKind().equals(SECAGG_CLIENT_LOG_EVENT)) {
        logger.atWarning().log(
            "Received secagg client log event without the message set. Dropping log.");
        return;
      }
      atomBuilder.setKind(translateTrainingEventKind(event.getKind()));
    }

    if (event.hasConfigName()) {
      atomBuilder.setConfigName(event.getConfigName());
    }

    if (event.hasDurationMs()) {
      atomBuilder.setDurationMillis(snapDurationToBucket(event.getDurationMs()));
    }

    if (event.hasExampleSize()) {
      atomBuilder.setExampleSize(event.getExampleSize());
    }

    if (event.hasRunId()) {
      atomBuilder.setRunId(event.getRunId());
    }

    if (event.hasErrorCode()) {
      atomBuilder.setErrorCode(TrainingErrorCode.forNumber(event.getErrorCode().getNumber()));
    }

    if (event.hasMemoryUsage()) {
      MemoryUsageInfo memInfo = event.getMemoryUsage();

      if (memInfo.hasNativeHeapBytesAllocated()) {
        atomBuilder.setNativeHeapBytesAllocated(
            snapBytesToKb(memInfo.getNativeHeapBytesAllocated()));
      }

      if (memInfo.hasJavaHeapTotalMemory()) {
        atomBuilder.setJavaHeapTotalMemory(snapBytesToKb(memInfo.getJavaHeapTotalMemory()));
      }

      if (memInfo.hasJavaHeapFreeMemory()) {
        atomBuilder.setJavaHeapFreeMemory(snapBytesToKb(memInfo.getJavaHeapFreeMemory()));
      }

      if (memInfo.hasHighWaterMarkMemoryBytes()) {
        atomBuilder.setHighWaterMarkMemoryBytes(
            snapBytesToKb(memInfo.getHighWaterMarkMemoryBytes()));
      }
    }

    if (event.hasModelIdentifier()) {
      atomBuilder.setModelIdentifier(event.getModelIdentifier());
    }

    if (event.hasDataTransfer()) {
      DataTransferInfo transferInfo = event.getDataTransfer();

      if (transferInfo.hasDurationMs()) {
        atomBuilder.setDataTransferDurationMillis(
            snapDurationToBucket(transferInfo.getDurationMs()));
      }

      if (transferInfo.hasChunkingLayerBytesUploaded()) {
        atomBuilder.setBytesUploaded(snapBytesToKb(transferInfo.getChunkingLayerBytesUploaded()));
      }

      if (transferInfo.hasChunkingLayerBytesDownloaded()) {
        atomBuilder.setBytesDownloaded(
            snapBytesToKb(transferInfo.getChunkingLayerBytesDownloaded()));
      }
    }

    if (event.hasErrorMessage() && flags.allowLoggingErrorMessage()) {
      atomBuilder.setErrorMessage(
          extractSafeErrorString(event.getErrorCode(), event.getKind(), event.getErrorMessage()));
    }

    if (event.hasDataSource()) {
      atomBuilder.setDataSource(
          TrainingDataSourceType.forNumber(event.getDataSource().getNumber()));
    }

    IntelligenceFederatedLearningTrainingLogReported atom = atomBuilder.build();
    if (validateSerializedAtomSize(atom)) {
      logger.atInfo().atMostEvery(INFO_LOG_MSG_PERIOD_MINUTES, MINUTES).log(
          "Sending FL Training log.");
      statsdLogger.logIntelligenceFlTrainingLogReported(atom);
    }
  }

  private void logSecAggEvent(TrainerLogEvent trainingEvent) {
    if (!flags.allowLoggingSecAggClientEvent() || !trainingEvent.hasSecaggClientLogEvent()) {
      return;
    }

    SecAggClientLogEvent secAggEvent = trainingEvent.getSecaggClientLogEvent();
    IntelligenceFederatedLearningSecAggClientLogReported.Builder atomBuilder =
        IntelligenceFederatedLearningSecAggClientLogReported.newBuilder()
            .setFederatedComputeVersion(FEDERATED_COMPUTE_VERSION);

    if (trainingEvent.hasRunId()) {
      atomBuilder.setRunId(trainingEvent.getRunId());
    }

    if (trainingEvent.hasConfigName()) {
      atomBuilder.setConfigName(trainingEvent.getConfigName());
    }

    if (trainingEvent.hasModelIdentifier()) {
      atomBuilder.setModelIdentifier(trainingEvent.getModelIdentifier());
    }

    if (secAggEvent.hasClientSessionId()) {
      atomBuilder.setClientSessionId(secAggEvent.getClientSessionId());
    }

    if (secAggEvent.hasExecutionSessionId()) {
      atomBuilder.setExecutionSessionId(secAggEvent.getExecutionSessionId());
    }

    if (secAggEvent.hasKind()) {
      atomBuilder.setKind(SecAggClientEventKind.forNumber(secAggEvent.getKind().getNumber()));
    }

    if (secAggEvent.hasDurationMs()) {
      atomBuilder.setDurationMillis(snapDurationToBucket(secAggEvent.getDurationMs()));
    }

    if (secAggEvent.hasRound()) {
      atomBuilder.setRound(SecAggClientRound.forNumber(secAggEvent.getRound().getNumber()));
    }

    if (secAggEvent.hasCryptoType()) {
      atomBuilder.setCryptoType(
          SecAggClientCryptoOperationType.forNumber(secAggEvent.getCryptoType().getNumber()));
    }

    if (secAggEvent.hasNumDroppedClients()) {
      atomBuilder.setNumDroppedClients(secAggEvent.getNumDroppedClients());
    }

    if (secAggEvent.hasReceivedMessageSize()) {
      atomBuilder.setReceivedMessageSize(snapBytesToKb(secAggEvent.getReceivedMessageSize()));
    }

    if (secAggEvent.hasSentMessageSize()) {
      atomBuilder.setSentMessageSize(snapBytesToKb(secAggEvent.getSentMessageSize()));
    }

    if (secAggEvent.hasErrorCode()) {
      atomBuilder.setErrorCode(
          SecAggClientErrorCode.forNumber(secAggEvent.getErrorCode().getNumber()));
    }

    IntelligenceFederatedLearningSecAggClientLogReported atom = atomBuilder.build();
    if (validateSerializedAtomSize(atom)) {
      logger.atInfo().atMostEvery(INFO_LOG_MSG_PERIOD_MINUTES, MINUTES).log(
          "Sending FL SecAgg log.");
      statsdLogger.logIntelligenceFlSecaggClientLogReported(atom);
    }
  }

  private boolean isLoggingEnabled() {
    return random.nextInt(100) < flags.logSamplingPercentage();
  }

  private boolean isTrainingCounterLoggingEnabled() {
    return random.nextInt(100) < flags.logCounterSamplingPercentage();
  }

  private long snapDurationToBucket(long durationMillis) {
    return durationBucketLogic.approximateDurationMs(
        durationBucketLogic.encodeDurationToBucket(durationMillis));
  }

  private boolean validateSerializedAtomSize(MessageLite atom) {
    int size = atom.getSerializedSize();
    if (size > flags.maxSerializedAtomSize()) {
      logger.atWarning().log("FL log event is larger [%d bytes] than size limit.", size);
      // TODO: We should log how often this happens.
      return false;
    }

    logger.atFine().log("FL log event is of size [%d bytes].", size);
    return true;
  }

  // Inserts all FcLogEvent containing network data transfer (upload/download).
  private void insertNetworkUsageLogRow(FcLogEvent event) {
    String packageName = event.getClientKey().getPackageName();

    if (!networkUsageLogRepository.isNetworkUsageLogEnabled()
        || !PCS_PACKAGE_NAME.equals(packageName)) {
      return;
    }

    TrainerLogEvent trainerLogEvent = event.getTrainerLog();
    long downloadSize =
        trainerLogEvent.getDataTransfer().hasChunkingLayerBytesDownloaded()
            ? trainerLogEvent.getDataTransfer().getChunkingLayerBytesDownloaded()
            : 0;
    long uploadSize =
        trainerLogEvent.getDataTransfer().hasChunkingLayerBytesUploaded()
            ? trainerLogEvent.getDataTransfer().getChunkingLayerBytesUploaded()
            : 0;
    NetworkUsageEntity entity =
        createFcTrainingResultNetworkUsageEntity(
            trainerLogEvent.getRunId(), downloadSize, uploadSize);

    networkUsageLogRepository.insertNetworkUsageEntity(entity);
  }

  private static String extractSafeErrorString(
      TrainerLogEvent.TrainingErrorCode errorCode,
      TrainerLogEvent.TrainingEventKind eventKind,
      String errorMsg) {
    if (isTensorFlowError(errorCode, eventKind)) {
      errorMsg = TfErrorParser.parse(errorMsg);
    }

    if (errorMsg.length() > 160) {
      errorMsg = errorMsg.substring(0, 160);
    }

    return errorMsg;
  }

  private static boolean isTensorFlowError(
      TrainerLogEvent.TrainingErrorCode errorCode, TrainerLogEvent.TrainingEventKind eventKind) {
    return errorCode.equals(TrainerLogEvent.TrainingErrorCode.TRAIN_ERROR_TENSORFLOW)
        || TENSOR_FLOW_ERROR_EVENTS.contains(eventKind);
  }

  private static TrainingEventKind translateTrainingEventKind(
      TrainerLogEvent.TrainingEventKind kind) {
    TrainingEventKind translated = TrainingEventKind.forNumber(kind.getNumber());
    if (translated == null) {
      logger.atWarning().log("Encountered unknown kind of TrainingEvent: [%d]", kind.getNumber());
      translated = TrainingEventKind.TRAIN_UNDEFINED;
    }

    return translated;
  }

  private static long snapBytesToKb(long bytes) {
    return (bytes >>> 10) << 10;
  }
}
